---
# example recipe
# --- !Recipe
!Recipe
name: !!str "example_recipe"

# A collection of definitions used throughout the recipe.
# This is not used by the framework at all, it is just a convenient place for
# definitions used repeatedly throughout the recipe.
common_definitions:
  # These columns that are converted to categorical data types
  # Note the definition of the anchor name `ccolumns` with the '&'
  categorical_columns: &ccolumns ['variable', 'vectorName', 'moduleName'
                             , 'v2x_rate', 'configname', 'experiment', 'repetition', 'runnumber'
                             , 'prefix', 'ql', 'mcmI', 'mcmL' ]
  # These columns that are converted to numerical data types, with explicit data type
  # Note the definition of the anchor name `ncolumns` with the '&'.
  numerical_columns_aoi: &ncolumns { 'coordination_aoi' : float, 'eventNumber' : int, 'simtimeRaw' : int }

evaluation: !Evaluation
  # It is advisable to use absolute paths everywhere, otherwise the path is
  # evaluated relative to the current working directory which may not be the same as the root directory of the project.
  tags: !include examples/tags.yaml

  extractors:
    - raw_aoi: !PatternMatchingBulkExtractor
        # The paths to the input files, every entry is parsed as a regular expression.
        # Or include an external file containing the YAML list
        # input_files: !include /opt/tmp/t-its-paper/review/all_ready_results.yaml
        input_files: !!python/list
            # - "/opt/tmp/hagau/data/SCO/ffk/.*MPR=0.2.*_2_2023.*vec$"
            # - "/opt/tmp/hagau/data/SCO/ffk/.*_2_2023.*vec$"
            # - "/opt/tmp/hagau/data/SC./ff.*/0_itsg5_FFK_SCO_8h_MPR=0.2_mcmI=0.1_mcmL=888_2_20230901-14:40:56_45.vec$"
            # - /opt/tmp/hagau/data/SC./ff(k|l)/.*_itsg5_FFK_SCO_8h_MPR=(0.1)_mcmI=0.1_mcmL=888_2_20230901-14:40:56_43.vec$

            # plain mode 
            # - /opt/tmp/hagau/data\(2\)/SC./ff(k|l)/.*_itsg5_FFK_SCO_8h_MPR=(0.1|0.4)_mcmI=(0.1|0.5)_mcmL=888_2_.*.vec$
            - /opt/tmp/hagau/data/SCO/ffk/0_itsg5_FFK_SCO_8h_MPR=0.1_mcmI=0.5_mcmL=.*_2_2023.*.vec$

            # single-quoted mode 
            # - '/opt/tmp/hagau/data\(2\)/SC./ff(k|l)/.*_itsg5_FFK_SCO_8h_MPR=(0.1)_mcmI=0.1_mcmL=888_2_20230901-14:40:56_43.vec$'
            # double-quoted mode 
            # - "/opt/tmp/hagau/data/SCO/ffk/0_itsg5_FFK_SCO_8h_MPR=0.1_mcmI=0.1_mcmL=888_2_20230901-14:40:56_43.vec$"
        # The pattern used for matching on the `vectorName` column.
        # Note the binding of the variable `index` to the distance coded into the signal name.
        pattern: "coordination_aoi_%:vector"
        # This is the name of the column containing the extracted data.
        alias: "coordination_aoi"

        # The pattern used for matching on the `vectorName` column.
        # Note the binding of the variables `index` and `gentime` to the id and generation time, respectively, coded into the signal name.
        alias_match_pattern: "coordination_aoi_(?P<index>[0-9]{1,4})_(?P<gentime>[0-9]{1,5}):vector"
        # The pattern used in naming each extracted signal.
        # Note the use of the variables `index` and `gentime` that have been extracted from the signal name with the `alias_match_pattern` specified above.
        # This is placed into the `variable` column.
        alias_pattern: "coordination_aoi_{index}_{gentime}"

        # These columns that are converted to categorical data types.
        categorical_columns: *ccolumns
        # These columns that are converted to numerical data types, with explicit data type.
        numerical_columns: *ncolumns
        simtimeRaw: !!bool "true"
        moduleName: !!bool "true"
        eventNumber: !!bool "true"
        # only add the minimal (plus the `additional_tags`) set of tags
        # (common_sets.BASE_TAGS_EXTRACTION_MINIMAL) to the output DataFrame
        # (default true)
        minimal_tags: !!bool "true"
        # the additional tags to add in addition to the base set
        additional_tags: [ 'mcmI', 'mcmL', 'ql' ]


  exporter:
    - raw_aoi: !FileResultProcessor
        dataset_name: "raw_aoi" # the key for the data loaded by the extractor above
        # don't concatenate all input DataFrames into one file
        concatenate: !bool "false"
        # the output directory to save to
        output_directory: "/opt/tmp/hagau/extracted/SCO/ffk/aoi"


plot: !Plot
  reader: # !!python/list
    - raw_aoi: !PlottingReaderFeather
        # sample: 0.5
        # concat: !!bool false
        # these columns that are converted to categorical data types
        # note the reference to the previously defined alias with the '*'
        categorical_columns: *ccolumns
        # these columns that are converted to numerical data types
        numerical_columns: *ncolumns
        input_files: !!python/list
          - /opt/tmp/hagau/extracted/SCO/ffk/aoi/.*SCO.*_2_2023.*.feather$


  transforms:
    - aoiTransform: !GroupedFunctionTransform
        # the key for the data loaded by the extractor above
        dataset_name: "raw_aoi"
        # the key for the generated data
        output_dataset_name: "mean_aoi"
        # the column with the input data
        input_column: "coordination_aoi"
        output_column: "mean_aoi"
        # the categorical variable used for splitting the input data into groups
        # over which the mean will be calculated
        grouping_columns: [ "prefix", "runnumber", "v2x_rate", "repetition", "moduleName", "variable" ]

        # this is auxiliary code that can be used for defining more complex aggregation functions
        # the evaluation of this code is contained to only a copy of the environment which is then used as context when evaluating 'aggregation_function'
        extra_code: |

          def calculate_cui(df):
              import time
              import numpy as np
              import math

              if df is None or (not df is None and df.empty):
                print(f'calculate_cui: {df=}')
                return math.nan

              sorted = df.sort_values(by=['simtimeRaw'])

              # the generation timestamp of the second message
              ts_generation = int(sorted['variable'].iat[0].split('_')[-1:][0])

              tsn = sorted['simtimeRaw'].tail(n=1).iat[0]
              # calculate difference in milliseconds
              td = (tsn * 1e-9) - ts_generation

              if td > 30e3:
                print(f">>>>>>>    {td=} is too large")


              if math.isclose(td, 0.):
                print("division by zero, returning NaN")
                print(f"{sorted=}")
                return math.nan


              sorted['coordination_aoi'] = sorted['coordination_aoi'].astype('float')

              # calculate average AoI estimate
              result = sorted['coordination_aoi'].sum() / td
              # print(f"{result=}")

              if result > 30e3:
                print(f"BIG VALUE")
                print(f"{sorted=}")
                print(f"{sorted['coordination_aoi'].sum()=}")
                print(f"{result=}")

              # this drops into an interactive debugging interface
              # start_debug()

              return result

        # The function to execute for each group
        # This should accept a pandas.Series as parameter and return a single value (when not outputting in raw mode).
        # This can be a function name, like "dask.dataframe.groupby.DataFrameGroupBy.mean" or "pd.Series.mean", possibly defined in `extra_code`.
        transform_function: "calculate_cui"

        # Whether to treat the result of the transform function as a single value (and augment it with the first row of the group data)
        # or as a pandas.Series (and assign it as a new column)
        aggregate: !!bool "true"

        # Whether to output a list of the raw result from the aggregation
        # function or add the result as a new column to to the first row of the
        # input data (the input column having been removed beforehand)
        # raw: !!bool "false"
        raw: !!null

        # Whether to concatenate all the input DataFrames into one before processing.
        # Separately processing of each DataFrame can be faster if possible.
        pre_concatenate: !!bool "true"

    # Replace a value in the `prefix` column with 'MCO' if it contains the substring 'MCO' and with 'SCO' in every other case.
    - rename_0: !ColumnFunctionTransform
        dataset_name: "mean_aoi"
        output_dataset_name: "mean_aoi"
        input_column: "prefix"
        output_column: "prefix"
        function: !code |
          lambda x: 'MCO' if 'MCO' in x else 'SCO'

    # This is equivalent to the above ColumnFunctionTransform, expect it operates on the `experiment` column.
    - rename_1: !FunctionTransform
        dataset_name: "mean_aoi"
        output_dataset_name: "mean_aoi"
        # The following function definition is an unnecessarily contrived example to show the use of helper functions and global variables.
        function: 'f'
        extra_code: |
          example_var = 23
          def f(df):
            print('------> f')
            print(f'------> {example_var=}')
            df = g(df)
            # start_debug()
            return df
          def g(df):
            print('------> g')
            df['experiment'] = df['experiment'].apply(lambda x: 'MCO' if 'MCO' in x else 'SCO')
            return df
          # The following definitions would overwrite the symbols under which
          # numpy and pandas have been imported, so one should be careful when
          # naming functions and choose unique and expressive names (unlike the
          # choices in the example above):
          # def np():
          #   pass
          # def pd():
          #   pass

    # Filter the input DataFrame by whether the `prefix` column of the row contains the substring 'SCO'
    - filter_SCO: !FunctionTransform
        dataset_name: "mean_aoi"
        output_dataset_name: "mean_aoi"
        function: |
          lambda df: df.query('prefix.str.contains("SCO")')


  tasks: # !!python/list
    - mean_aoi_interval_box: !PlottingTask
        # The key used for selecting from the data loaded and/or transformed in the reader and transform phases.
        dataset_name: "mean_aoi"
        plot_type: "box"

        x: "v2x_rate"
        y: "mean_aoi"

        yrange: !!tuple (0., 2750.)

        hue: &hue "mcmI"
        row: !!null
        column: "mcmL"

        alpha: 0.9

        xlabel: "MPR"
        ylabel: "AOI [ms]"

        # default row/column title template
        # title_template: !!null
        title_template: "{col_name}"

        # no legend title
        # legend_title: "mcmI"
        legend_title: *hue
        # legend_title: !!null
        # custom legend title
        # legend_title: "Repetition"
        # the location of the legend
        legend_location: "center"
        # legend: !!null

        axes_style: "dark"
        bbox_inches: "tight"

        colormap: "plasma"

        plot_kwargs:
          aspect: 1.5

        matplotlib_backend: "agg"
        # matplotlib_rc: "/misc/ibr/projects/artery-lte/artery_imagine_hagau_release_t-its_paccrunch/scripts/examples/AOI.matplotlib.rc"
        # matplotlib_rc: |
        #     boxplot.whiskerprops.color : red
        #     boxplot.medianprops.color :   yellow
        # the definition for matplotlib.rc can be given in multiple ways:
        # - as an external file and included via `!!include`
        # matplotlib_rc: !include "/misc/ibr/projects/artery-lte/artery_imagine_hagau_release_t-its_paccrunch/scripts/examples/AOI.matplotlib.rc"
        # - as a literal style block scalar (see https://yaml.org/spec/1.2.2/#812-literal-style)
        matplotlib_rc: |
                font.size : 10
                axes.titlesize : 10
                axes.linewidth : 0.5
                xtick.major.width : 0.5
                ytick.major.width : 0.5
                text.usetex : True
                font.family : 'serif'
                # increase DPI for more pixel in your PNGs
                figure.dpi : 200
                figure.figsize : (2, 2)
                legend.loc : best
        # - as a mapping
        # matplotlib_rc: {
        #         'font.size' : 10
        #       , 'axes.titlesize' : 10
        #       , 'axes.linewidth' : 0.5
        #       , 'xtick.major.width' : 0.5
        #       , 'ytick.major.width' : 0.5
        #       , 'text.usetex' : True
        #       , 'font.family' : 'serif'
        #       , 'figure.dpi' : 72
        #       # the `!!python/tuple` tag is required for proper type
        #       conversion, otherwise everything after the comma in the tuple
        #       is interpreted as key for the next entry (with `None` as value)
        #
        #       , 'figure.figsize': !!python/tuple [8.268, 2.25]
        #       }

        # output_file: "/net/i5/opt/tmpssd/t-its-paper/review/plots/aoi.png"
        # output_file: "/opt/tmp/hagau/tmp/obstacles/aoi_box.png"
        # output_file: "/opt/tmp/t-its-paper/review/test/plots/aoi_box.png"
        # output_file: "/opt/tmp/t-its-paper/review/plots/aoi_over_mpr_ql=2_interval_boxplot.png"
        # output_file: "/opt/tmp/t-its-paper/review/plots/aoi_over_mpr_mcmL=888_ql=2_interval_boxplot.png"
        # output_file: "/opt/tmp/hagau/tmp/aoi_over_mpr_mcmL=888_ql=2_interval_boxplot_no-concat.png"
        output_file: "/opt/tmp/hagau/plots/aoi.png"

        # The `grid_transform` function takes the produced seaborn.FacetGrid as
        # argument and can apply arbitrary operations to it before it is saved to disk.
        grid_transform: |
            def grid_transform(ax):
                font_scale = 1.5
                sb.set_context('paper', font_scale=font_scale)
                sb.set_theme(style="darkgrid", font_scale=font_scale)
                sb.set_palette('colorblind')

                sec_x_axis_label_rotation = 0
                sec_y_axis_label_rotation = -90
                x_axis_style = 'distance'
                y_axis_style = 'pdr'
                ylimit = (0., 1.)
                fontsize = 10

                mprs = [0.05, 0.1 , 0.2 , 0.4 , 0.6 , 0.8 , 1.  ]
                mpr_labels = ['0.05', '0.1' , 0.2 , 0.4 , 0.6 , 0.8 , 1.  ]

                # start_debug()

                # set labels and ticks for the x-axis
                for col in range(0, ax._ncol):
                  # ax._axes[0][col].set_xticks(mprs)
                  ax._axes[0][col].set_xticklabels(mpr_labels)
                  ax._axes[0][col].tick_params(which='both', labelsize=fontsize)
                  ax._axes[0][col].set_xlabel(ax._axes[0][col]._axes.get_xlabel(), fontsize=fontsize)
                  ax._axes[0][col].set_title(ax._axes[0][col]._axes.get_title(), fontsize=fontsize)

                ax._axes[0][0].set_ylabel(ax._axes[0][0]._axes.get_ylabel(), fontsize=fontsize)

                # for row, row_name in zip(range(0, ax._nrow + 1), ax.row_names):
                #     sec_ax = ax._axes[row][ax._ncol - 1].secondary_yaxis(location='right')

                #     if y_axis_style == 'cbr':
                #         sec_ax.set_yticks([ .4 ])
                #     if y_axis_style in [ 'sia', 'ct', 'per', 'tx', 'pdr' ]:
                #         sec_ax.set_yticks([ ylimit[1] / 2. ])
                #     if y_axis_style in [ 'pdr' ]:
                #         sec_ax.set_yticks([ .6 ])
                #     sec_ax.set_yticklabels([ str(row_name)+' B' ], rotation=sec_y_axis_label_rotation)
                #     if row == 1:
                #         sec_ax.set_ylabel('mcmL', rotation=-90, loc='center', labelpad=20.)
                #     sec_ax.tick_params(length=0.)

                # for col, col_name in zip(range(0, ax._ncol + 1), ax.col_names):
                #     sec_ax = ax._axes[0][col].secondary_xaxis(location='top')

                #     sec_ax.set_xticks([ .5 ])

                #     sec_ax.set_xticklabels([ str(col_name)+' s' ], rotation=sec_x_axis_label_rotation)
                #     if col == 1:
                #         sec_ax.set_xlabel('mcmI', rotation=sec_x_axis_label_rotation, loc='right', labelpad=1.)
                #     sec_ax.tick_params(length=0.)

                legend_loc = 'center'
                legend_bb = (.03, .57, .3, .3)
                ncol = 1
                borderpad = .4 # 1.2
                legend_title = 'mcmI'
                legend_fontsize = 13
                sb.move_legend(ax, loc=legend_loc, bbox_to_anchor=legend_bb, ncol=ncol, mode='extend', borderpad=borderpad
                              , fontsize=legend_fontsize, title=legend_title
                              , frameon=True
                              , title_fontsize=12
                              )

                # from common.debug import start_ipython_dbg_cmdline
                # start_ipython_dbg_cmdline(locals())

                return ax


    # - mean_aoi_interval_line: !!prototype *mean_aoi_interval_box
    #     # derive: *mean_aoi_interval_box
    #     plot_type: "line"
    #     output_file: "/opt/tmp/t-its-paper/review/plots/aoi_over_mpr_mcmL=888_ql=2_interval_lineplot.png"


    # - mean_aoi: !PlottingTask
    #     # the key used for selecting from the data loaded and/or transformed in
    #     # the reader and transform phases
    #     dataset_name: "mean_aoi"
    #     # dataset_name: "cbr_stats"
    #     selector: "ql == 2 and prefix=='itsg5_FFK_SCO'"
    #     # the kind of plot to draw
    #     # one of { 'lineplot', 'box', 'scatterplot'
    #     #        , 'boxen', 'stripplot', 'swarm', 'bar', 'count'
    #     #        , 'point'
    #     #        , ... }
    #     plot_type: "ecdf"
    #     # plot_type: "box"
    #     # plot_type: "lineplot"

    #     # x: "v2x_rate"
    #     # y: "mean_aoi"

    #     x: "mean_aoi"
    #     y: !none

    #     # yrange: "(0., 0.8)"

    #     # x: "v2x_rate"
    #     # y: "cbr"
    #     # y: "cbr_mean"
    #     # y: "mean"
    #     # y: "50%"

    #     # x: !!null
    #     # y: "cbr"

    #     # hue: "moduleName"
    #     # hue: "repetition"
    #     # hue: "prefix"
    #     hue: "v2x_rate"
    #     # hue: !!null
    #     row: "mcmL"
    #     # row: "moduleName"
    #     # row: !!null
    #     # column: "v2x_rate"
    #     # column: "prefix"
    #     column: "mcmI"
    #     # column: "moduleName"
    #     # column: !!null
    #     #
    #     alpha: 0.9

    #     xlabel: "AOI (ms)"
    #     ylabel: "Proportion"

    #     # default row/column title template
    #     # title_template: !!null
    #     # title_template: ""

    #     # no legend title
    #     # legend_title: ""
    #     # legend_title: !!null
    #     # custom legend title
    #     legend_title: "Repetition"
    #     # the location of the legend
    #     legend_location: "center right"
    #     legend: !!null

    #     axes_style: "dark"
    #     bbox_inches: "tight"

    #     # colormap: "plasma"

    #     matplotlib_backend: "agg"
    #     matplotlib_rc: !null
    #     # output_file: "/net/i5/opt/tmpssd/t-its-paper/review/plots/aoi.png"
    #     output_file: "/opt/tmp/t-its-paper/review/test/plots/aoi_ecdf.png"


    # - mean_aoi_box: !PlottingTask
    #     # the key used for selecting from the data loaded and/or transformed in
    #     # the reader and transform phases
    #     dataset_name: "mean_aoi"
    #     # dataset_name: "cbr_stats"
    #     selector: "ql == 2"
    #     # the kind of plot to draw
    #     # one of { 'lineplot', 'box', 'scatterplot'
    #     #        , 'boxen', 'stripplot', 'swarm', 'bar', 'count'
    #     #        , 'point'
    #     #        , ... }
    #     plot_type: "box"
    #     # plot_type: "box"
    #     # plot_type: "lineplot"

    #     # x: "v2x_rate"
    #     # y: "mean_aoi"

    #     x: "v2x_rate"
    #     # y: !none
    #     y: "mean_aoi"

    #     yrange: "(0., 3000.)"

    #     # x: "v2x_rate"
    #     # y: "cbr"
    #     # y: "cbr_mean"
    #     # y: "mean"
    #     # y: "50%"

    #     # x: !!null
    #     # y: "cbr"

    #     # hue: "moduleName"
    #     # hue: "repetition"
    #     hue: "prefix"
    #     # hue: "v2x_rate"
    #     # hue: !!null
    #     row: "mcmL"
    #     # row: "moduleName"
    #     # row: !!null
    #     # column: "v2x_rate"
    #     # column: "prefix"
    #     column: "mcmI"
    #     # column: "moduleName"
    #     # column: !!null
    #     #
    #     alpha: 0.9

    #     xlabel: "MPR"
    #     ylabel: "AOI (ms)"

    #     # default row/column title template
    #     # title_template: !!null
    #     # title_template: ""

    #     # no legend title
    #     # legend_title: ""
    #     legend_title: !!null
    #     # custom legend title
    #     # legend_title: "Repetition"
    #     # the location of the legend
    #     legend_location: "center right"
    #     legend: !!null

    #     axes_style: "dark"
    #     bbox_inches: "tight"

    #     # colormap: "plasma"

    #     matplotlib_backend: "agg"
    #     matplotlib_rc: !null
    #     # output_file: "/net/i5/opt/tmpssd/t-its-paper/review/plots/aoi.png"
    #     # output_file: "/opt/tmp/hagau/tmp/obstacles/aoi_box.png"
    #     # output_file: "/opt/tmp/t-its-paper/review/test/plots/aoi_box.png"
    #     output_file: "/opt/tmp/t-its-paper/review/i3/plots/aoi_ql=2_box.png"

    # - mean_aoi_line: !PlottingTask
    #     # the key used for selecting from the data loaded and/or transformed in
    #     # the reader and transform phases
    #     dataset_name: "mean_aoi"
    #     # dataset_name: "cbr_stats"
    #     selector: "ql == 2"
    #     # the kind of plot to draw
    #     # one of { 'lineplot', 'box', 'scatterplot'
    #     #        , 'boxen', 'stripplot', 'swarm', 'bar', 'count'
    #     #        , 'point'
    #     #        , ... }
    #     plot_type: "lineplot"
    #     # plot_type: "box"
    #     # plot_type: "lineplot"

    #     # x: "v2x_rate"
    #     # y: "mean_aoi"

    #     x: "v2x_rate"
    #     # y: !none
    #     y: "mean_aoi"

    #     yrange: "(0., 2000.)"

    #     # x: "v2x_rate"
    #     # y: "cbr"
    #     # y: "cbr_mean"
    #     # y: "mean"
    #     # y: "50%"

    #     # x: !!null
    #     # y: "cbr"

    #     # hue: "moduleName"
    #     # hue: "repetition"
    #     hue: "prefix"
    #     # hue: "v2x_rate"
    #     # hue: !!null
    #     row: "mcmL"
    #     # row: "moduleName"
    #     # row: !!null
    #     # column: "v2x_rate"
    #     # column: "prefix"
    #     column: "mcmI"
    #     # column: "moduleName"
    #     # column: !!null
    #     #
    #     alpha: 0.9

    #     xlabel: "MPR"
    #     ylabel: "AOI (ms)"

    #     # default row/column title template
    #     # title_template: !!null
    #     # title_template: ""

    #     # no legend title
    #     # legend_title: ""
    #     legend_title: !!null
    #     # custom legend title
    #     # legend_title: "Repetition"
    #     # the location of the legend
    #     legend_location: "center right"
    #     legend: !!null

    #     axes_style: "dark"
    #     bbox_inches: "tight"

    #     # colormap: "plasma"

    #     matplotlib_backend: "agg"
    #     matplotlib_rc: !null
    #     # output_file: "/net/i5/opt/tmpssd/t-its-paper/review/plots/aoi.png"
    #     # output_file: "/opt/tmp/t-its-paper/review/test/plots/aoi_line.png"
    #     output_file: "/opt/tmp/t-its-paper/review/i3/plots/aoi_ql=2.png"

        # grid_transform: |
        #     def grid_transform(ax):
        #         sec_x_axis_label_rotation = 0
        #         sec_y_axis_label_rotation = -90
        #         x_axis_style = 'mpr'
        #         y_axis_style = 'pdr'
        #         ylimit = (0., 1.)

        #         for row, row_name in zip(range(0, ax._nrow + 1), ax.row_names):
        #             sec_ax = ax._axes[row][ax._ncol - 1].secondary_yaxis(location='right')

        #             sec_ax.set_yticks([ ylimit[1] / 2. ])
        #             sec_ax.set_yticklabels([ str(row_name)+' B' ], rotation=sec_y_axis_label_rotation)

        #             if row == 1:
        #                 sec_ax.set_ylabel('mcmL', rotation=-90, loc='center', labelpad=20.)
        #             sec_ax.tick_params(length=0.)

        #         for col, col_name in zip(range(0, ax._ncol + 1), ax.col_names):
        #             sec_ax = ax._axes[0][col].secondary_xaxis(location='top')

        #             # if x_axis_style == 'mpr':
        #             #     if kind=='line':
        #             #         sec_ax.set_xticks([ .5 ])
        #             #     if kind=='box':
        #             #         sec_ax.set_xticks([ 3 ])

        #             sec_ax.set_xticklabels([ str(col_name)+' s' ], rotation=sec_x_axis_label_rotation)
        #             if col == 1:
        #                 sec_ax.set_xlabel('mcmI', rotation=sec_x_axis_label_rotation, loc='right', labelpad=1.)
        #             sec_ax.tick_params(length=0.)

        #         return ax

...
